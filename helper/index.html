<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Image Stitcher</title>
<style>
  body { font-family: sans-serif; text-align: center; background: #f4f4f4; }
  #images { display: flex; flex-wrap: wrap; justify-content: center; margin-top: 1em; }
  #images img { height: 100px; margin: 5px; object-fit: contain; border: 1px solid #ccc; }
  canvas { margin-top: 1em; border: 1px solid #000; background: white; }
  .controls button { margin: 5px; padding: 8px 12px; }
</style>
</head>
<body>
<h1>Image Stitcher</h1>
<input type="file" id="fileInput" multiple accept="image/*">
<div class="controls">
  <button id="duplicateLastBtn">Duplicate Last Image</button>
  <button id="stitchBtn">Stitch Images</button>
  <button id="downloadBtn">Download</button>
  <button id="squareToggleBtn">Make Square: OFF</button>
  <button id="alphaToggleBtn">Preserve Alpha: OFF</button> <!-- ✅ New toggle -->
</div>
<label>Max Images per Row: <input type="number" id="maxPerRow" value="5" min="1" style="width:50px"></label>
<div id="images"></div>
<canvas id="canvas"></canvas>

<script>
const fileInput = document.getElementById('fileInput');
const imagesDiv = document.getElementById('images');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const duplicateLastBtn = document.getElementById('duplicateLastBtn');
const stitchBtn = document.getElementById('stitchBtn');
const downloadBtn = document.getElementById('downloadBtn');
const squareToggleBtn = document.getElementById('squareToggleBtn');
const alphaToggleBtn = document.getElementById('alphaToggleBtn'); // ✅
let images = [];
let makeSquare = false;
let preserveAlpha = false; // ✅

fileInput.addEventListener('change', e => {
  for (const file of e.target.files) {
    const img = new Image();
    img.src = URL.createObjectURL(file);
    img.onload = () => { images.push(img); renderPreviews(); };
  }
});

duplicateLastBtn.addEventListener('click', () => {
  if (images.length > 0) {
    const last = images[images.length - 1];
    const copy = new Image();
    copy.src = last.src;
    copy.onload = () => { images.push(copy); renderPreviews(); };
  }
});

squareToggleBtn.addEventListener('click', () => {
  makeSquare = !makeSquare;
  squareToggleBtn.textContent = `Make Square: ${makeSquare ? 'ON' : 'OFF'}`;
});

// ✅ Preserve Alpha toggle
alphaToggleBtn.addEventListener('click', () => {
  preserveAlpha = !preserveAlpha;
  alphaToggleBtn.textContent = `Preserve Alpha: ${preserveAlpha ? 'ON' : 'OFF'}`;
  canvas.style.background = preserveAlpha ? 'transparent' : 'white';
});

stitchBtn.addEventListener('click', () => {
  if (images.length === 0) return alert('No images selected');
  const maxPerRow = parseInt(document.getElementById('maxPerRow').value) || images.length;
  const rowHeight = Math.max(...images.map(img => img.height));
  const rows = Math.ceil(images.length / maxPerRow);
  const rowWidths = [];
  let width = 0;

  for (let i = 0; i < rows; i++) {
    const rowImgs = images.slice(i * maxPerRow, (i + 1) * maxPerRow);
    rowWidths.push(rowImgs.reduce((w, img) => w + img.width, 0));
  }

  const totalWidth = Math.max(...rowWidths);
  const totalHeight = rows * rowHeight;

  let finalWidth = totalWidth;
  let finalHeight = totalHeight;

  if (makeSquare) {
    const maxSide = Math.max(finalWidth, finalHeight);
    finalWidth = finalHeight = maxSide;
  }

  // ✅ Enable or disable alpha depending on toggle
  const tempCanvas = document.createElement('canvas');
  tempCanvas.width = finalWidth;
  tempCanvas.height = finalHeight;
  const tempCtx = tempCanvas.getContext('2d', { alpha: preserveAlpha });

  // ✅ Background fill only if not preserving alpha
  if (!preserveAlpha) {
    tempCtx.fillStyle = "#fff";
    tempCtx.fillRect(0, 0, finalWidth, finalHeight);
  } else {
    tempCtx.clearRect(0, 0, finalWidth, finalHeight);
  }

  let y = 0;
  for (let i = 0; i < rows; i++) {
    const rowImgs = images.slice(i * maxPerRow, (i + 1) * maxPerRow);
    let x = 0;
    for (const img of rowImgs) {
      tempCtx.drawImage(img, x, y, img.width, img.height);
      x += img.width;
    }
    y += rowHeight;
  }

  if (makeSquare && totalWidth < totalHeight) {
    const diff = (finalWidth - totalWidth) / 2;
    const tempData = tempCtx.getImageData(0, 0, totalWidth, totalHeight);
    tempCtx.clearRect(0, 0, finalWidth, finalHeight);
    tempCtx.putImageData(tempData, diff, 0);
  }

  // Copy to main canvas
  canvas.width = finalWidth;
  canvas.height = finalHeight;
  ctx.clearRect(0, 0, finalWidth, finalHeight);
  ctx.drawImage(tempCanvas, 0, 0);
});

downloadBtn.addEventListener('click', () => {
  const link = document.createElement('a');
  link.download = 'stitched.png';
  // ✅ Preserve alpha in export too
  link.href = canvas.toDataURL('image/png');
  link.click();
});

function renderPreviews() {
  imagesDiv.innerHTML = '';
  for (const img of images) {
    imagesDiv.appendChild(img.cloneNode());
  }
}
</script>
</body>
</html>
